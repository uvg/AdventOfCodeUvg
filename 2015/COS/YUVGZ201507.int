ROUTINE YUVGZ201507 [Type=INT]
YUVGZ201507	;https://adventofcode.com/2015/day/7;
	//Intersystems developer community id: 130669-ab1f69bf
	quit
	/*
af AND ah -> ai
NOT lk -> ll
hz RSHIFT 1 -> is
NOT go -> gp
du OR dt -> dv
x RSHIFT 5 -> aa
at OR az -> ba
eo LSHIFT 15 -> es
ci OR ct -> cu
b RSHIFT 5 -> f
fm OR fn -> fo
NOT ag -> ah
v OR w -> x
g AND i -> j
an LSHIFT 15 -> ar
1 AND cx -> cy
jq AND jw -> jy
iu RSHIFT 5 -> ix
gl AND gm -> go
NOT bw -> bx
jp RSHIFT 3 -> jr
hg AND hh -> hj
bv AND bx -> by
er OR es -> et
kl OR kr -> ks
et RSHIFT 1 -> fm
e AND f -> h
u LSHIFT 1 -> ao
he RSHIFT 1 -> hx
eg AND ei -> ej
bo AND bu -> bw
dz OR ef -> eg
dy RSHIFT 3 -> ea
gl OR gm -> gn
da LSHIFT 1 -> du
au OR av -> aw
gj OR gu -> gv
eu OR fa -> fb
lg OR lm -> ln
e OR f -> g
NOT dm -> dn
NOT l -> m
aq OR ar -> as
gj RSHIFT 5 -> gm
hm AND ho -> hp
ge LSHIFT 15 -> gi
jp RSHIFT 1 -> ki
hg OR hh -> hi
lc LSHIFT 1 -> lw
km OR kn -> ko
eq LSHIFT 1 -> fk
1 AND am -> an
gj RSHIFT 1 -> hc
aj AND al -> am
gj AND gu -> gw
ko AND kq -> kr
ha OR gz -> hb
bn OR by -> bz
iv OR jb -> jc
NOT ac -> ad
bo OR bu -> bv
d AND j -> l
bk LSHIFT 1 -> ce
de OR dk -> dl
dd RSHIFT 1 -> dw
hz AND ik -> im
NOT jd -> je
fo RSHIFT 2 -> fp
hb LSHIFT 1 -> hv
lf RSHIFT 2 -> lg
gj RSHIFT 3 -> gl
ki OR kj -> kk
NOT ak -> al
ld OR le -> lf
ci RSHIFT 3 -> ck
1 AND cc -> cd
NOT kx -> ky
fp OR fv -> fw
ev AND ew -> ey
dt LSHIFT 15 -> dx
NOT ax -> ay
bp AND bq -> bs
NOT ii -> ij
ci AND ct -> cv
iq OR ip -> ir
x RSHIFT 2 -> y
fq OR fr -> fs
bn RSHIFT 5 -> bq
0 -> c
14146 -> b
d OR j -> k
z OR aa -> ab
gf OR ge -> gg
df OR dg -> dh
NOT hj -> hk
NOT di -> dj
fj LSHIFT 15 -> fn
lf RSHIFT 1 -> ly
b AND n -> p
jq OR jw -> jx
gn AND gp -> gq
x RSHIFT 1 -> aq
ex AND ez -> fa
NOT fc -> fd
bj OR bi -> bk
as RSHIFT 5 -> av
hu LSHIFT 15 -> hy
NOT gs -> gt
fs AND fu -> fv
dh AND dj -> dk
bz AND cb -> cc
dy RSHIFT 1 -> er
hc OR hd -> he
fo OR fz -> ga
t OR s -> u
b RSHIFT 2 -> d
NOT jy -> jz
hz RSHIFT 2 -> ia
kk AND kv -> kx
ga AND gc -> gd
fl LSHIFT 1 -> gf
bn AND by -> ca
NOT hr -> hs
NOT bs -> bt
lf RSHIFT 3 -> lh
au AND av -> ax
1 AND gd -> ge
jr OR js -> jt
fw AND fy -> fz
NOT iz -> ja
c LSHIFT 1 -> t
dy RSHIFT 5 -> eb
bp OR bq -> br
NOT h -> i
1 AND ds -> dt
ab AND ad -> ae
ap LSHIFT 1 -> bj
br AND bt -> bu
NOT ca -> cb
NOT el -> em
s LSHIFT 15 -> w
gk OR gq -> gr
ff AND fh -> fi
kf LSHIFT 15 -> kj
fp AND fv -> fx
lh OR li -> lj
bn RSHIFT 3 -> bp
jp OR ka -> kb
lw OR lv -> lx
iy AND ja -> jb
dy OR ej -> ek
1 AND bh -> bi
NOT kt -> ku
ao OR an -> ap
ia AND ig -> ii
NOT ey -> ez
bn RSHIFT 1 -> cg
fk OR fj -> fl
ce OR cd -> cf
eu AND fa -> fc
kg OR kf -> kh
jr AND js -> ju
iu RSHIFT 3 -> iw
df AND dg -> di
dl AND dn -> do
la LSHIFT 15 -> le
fo RSHIFT 1 -> gh
NOT gw -> gx
NOT gb -> gc
ir LSHIFT 1 -> jl
x AND ai -> ak
he RSHIFT 5 -> hh
1 AND lu -> lv
NOT ft -> fu
gh OR gi -> gj
lf RSHIFT 5 -> li
x RSHIFT 3 -> z
b RSHIFT 3 -> e
he RSHIFT 2 -> hf
NOT fx -> fy
jt AND jv -> jw
hx OR hy -> hz
jp AND ka -> kc
fb AND fd -> fe
hz OR ik -> il
ci RSHIFT 1 -> db
fo AND fz -> gb
fq AND fr -> ft
gj RSHIFT 2 -> gk
cg OR ch -> ci
cd LSHIFT 15 -> ch
jm LSHIFT 1 -> kg
ih AND ij -> ik
fo RSHIFT 3 -> fq
fo RSHIFT 5 -> fr
1 AND fi -> fj
1 AND kz -> la
iu AND jf -> jh
cq AND cs -> ct
dv LSHIFT 1 -> ep
hf OR hl -> hm
km AND kn -> kp
de AND dk -> dm
dd RSHIFT 5 -> dg
NOT lo -> lp
NOT ju -> jv
NOT fg -> fh
cm AND co -> cp
ea AND eb -> ed
dd RSHIFT 3 -> df
gr AND gt -> gu
ep OR eo -> eq
cj AND cp -> cr
lf OR lq -> lr
gg LSHIFT 1 -> ha
et RSHIFT 2 -> eu
NOT jh -> ji
ek AND em -> en
jk LSHIFT 15 -> jo
ia OR ig -> ih
gv AND gx -> gy
et AND fe -> fg
lh AND li -> lk
1 AND io -> ip
kb AND kd -> ke
kk RSHIFT 5 -> kn
id AND if -> ig
NOT ls -> lt
dw OR dx -> dy
dd AND do -> dq
lf AND lq -> ls
NOT kc -> kd
dy AND ej -> el
1 AND ke -> kf
et OR fe -> ff
hz RSHIFT 5 -> ic
dd OR do -> dp
cj OR cp -> cq
NOT dq -> dr
kk RSHIFT 1 -> ld
jg AND ji -> jj
he OR hp -> hq
hi AND hk -> hl
dp AND dr -> ds
dz AND ef -> eh
hz RSHIFT 3 -> ib
db OR dc -> dd
hw LSHIFT 1 -> iq
he AND hp -> hr
NOT cr -> cs
lg AND lm -> lo
hv OR hu -> hw
il AND in -> io
NOT eh -> ei
gz LSHIFT 15 -> hd
gk AND gq -> gs
1 AND en -> eo
NOT kp -> kq
et RSHIFT 5 -> ew
lj AND ll -> lm
he RSHIFT 3 -> hg
et RSHIFT 3 -> ev
as AND bd -> bf
cu AND cw -> cx
jx AND jz -> ka
b OR n -> o
be AND bg -> bh
1 AND ht -> hu
1 AND gy -> gz
NOT hn -> ho
ck OR cl -> cm
ec AND ee -> ef
lv LSHIFT 15 -> lz
ks AND ku -> kv
NOT ie -> if
hf AND hl -> hn
1 AND r -> s
ib AND ic -> ie
hq AND hs -> ht
y AND ae -> ag
NOT ed -> ee
bi LSHIFT 15 -> bm
dy RSHIFT 2 -> dz
ci RSHIFT 2 -> cj
NOT bf -> bg
NOT im -> in
ev OR ew -> ex
ib OR ic -> id
bn RSHIFT 2 -> bo
dd RSHIFT 2 -> de
bl OR bm -> bn
as RSHIFT 1 -> bl
ea OR eb -> ec
ln AND lp -> lq
kk RSHIFT 3 -> km
is OR it -> iu
iu RSHIFT 2 -> iv
as OR bd -> be
ip LSHIFT 15 -> it
iw OR ix -> iy
kk RSHIFT 2 -> kl
NOT bb -> bc
ci RSHIFT 5 -> cl
ly OR lz -> ma
z AND aa -> ac
iu RSHIFT 1 -> jn
cy LSHIFT 15 -> dc
cf LSHIFT 1 -> cz
as RSHIFT 3 -> au
cz OR cy -> da
kw AND ky -> kz
lx -> a
iw AND ix -> iz
lr AND lt -> lu
jp RSHIFT 5 -> js
aw AND ay -> az
jc AND je -> jf
lb OR la -> lc
NOT cn -> co
kh LSHIFT 1 -> lb
1 AND jj -> jk
y OR ae -> af
ck AND cl -> cn
kk OR kv -> kw
NOT cv -> cw
kl AND kr -> kt
iu OR jf -> jg
at AND az -> bb
jp RSHIFT 2 -> jq
iv AND jb -> jd
jn OR jo -> jp
x OR ai -> aj
ba AND bc -> bd
jl OR jk -> jm
b RSHIFT 1 -> v
o AND q -> r
NOT p -> q
k AND m -> n
as RSHIFT 2 -> at
	*/
	/*
This year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.

Each wire has an identifier (some lowercase letters) and can carry a 16-bit signal (a number from 0 to 65535). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.

The included instructions booklet describes how to connect the parts together: x AND y -> z means to connect wires x and y to an AND gate, and then connect its output to wire z.

For example:

123 -> x means that the signal 123 is provided to wire x.
x AND y -> z means that the bitwise AND of wire x and wire y is provided to wire z.
p LSHIFT 2 -> q means that the value from wire p is left-shifted by 2 and then provided to wire q.
NOT e -> f means that the bitwise complement of the value from wire e is provided to wire f.
Other possible gates include OR (bitwise OR) and RSHIFT (right-shift). If, for some reason, you'd like to emulate the circuit instead, almost all programming languages (for example, C, JavaScript, or Python) provide operators for these gates.

For example, here is a simple circuit:

123 -> x
456 -> y
x AND y -> d
x OR y -> e
x LSHIFT 2 -> f
y RSHIFT 2 -> g
NOT x -> h
NOT y -> i
After it is run, these are the signals on the wires:

d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
In little Bobby's kit's instructions booklet (provided as your puzzle input), what signal is ultimately provided to wire a?
	*/
Part1(FileName="",RecordsArr) PUBLIC
{
	if $data(RecordsArr)'=10 {
		if '$length(FileName) {
			read !,"Enter filename: ",FileName
			write !
		}
		if '$length(FileName) {
			write !,"Missing file to read from"
			quit 0
		}
		quit:'$$LoadFile(FileName,.RecordsArr) 0
		if '$data(RecordsArr) {
			write !,"No data was red from "_FileName
			quit 0
		}
	}
	quit:'$$CheckData(.RecordsArr) 0
	set Line="" for  {
		set Line=$order(RecordsArr(Line)) quit:Line=""
		set Data=RecordsArr(Line),To=$piece(Data," -> ",2)
		set Command=$piece(Data," -> ",1)
		if $length(Command," ")=1 {
			set Tree(Command,To)=1 //1 - Simple assignment
		}
		elseif $length(Command," ")=2 {
			set Tree($piece(Command," ",2),To)=2 //2 - NOT (bitwise complement)
		}
		else {
			set Operation=$piece(Command," ",2) //3 - OR, 4 - AND, 5 - RSHIFT, 6 - LSHIFT
			set Operation=$case(Operation,"OR":3,"AND":4,"RSHIFT":5,"LSHIFT":6)
			set Tree($piece(Command," ",1),To)=Operation_","_$piece(Command," ",3)
			set Tree($piece(Command," ",3),To)=Operation
		}
	}
	set Node="",ERR="" for  {
		set Node=$order(Tree(Node)) quit:Node=""
		do ComputeHeight(Node,.Tree)
		set To="" for  {
			set To=$order(Tree(Node,To)) quit:To=""
			if '$data(Tree(To)),To'="a",To'="ma" set ERR="Wire "_To_" (from "_Node_") is missing in data" quit  //'ma' & 'a' wires aren't inputs for other gates nor wires
			//set $piece(Tree(Node,To),",",2)=+$get(Tree(To))
		}
		quit:$length(ERR)
	}
	if $length(ERR) write !,ERR quit 0
	set Node="" for  {
		set Node=$order(Tree(Node)) quit:Node=""
		set Height=Tree(Node)
		//set OrderedTree(Height,Node)=""
		set To="" for  {
			set To=$order(Tree(Node,To)) quit:To=""
			set Data=Tree(Node,To)
			if Data>2,Data'["," continue
			set HeightTo=+$get(Tree(To))
			set OrderedTree(HeightTo,Height,Node,To)=Data
		}
	}
	set Level1="" for  {
		set Level1=$order(OrderedTree(Level1),-1) quit:Level1=""
		set Level2="" for  {
			set Level2=$order(OrderedTree(Level1,Level2),-1) quit:Level2=""
			set Val1="" for  {
				set Val1=$order(OrderedTree(Level1,Level2,Val1),-1) quit:Val1=""
				set To="" for  {
					set To=$order(OrderedTree(Level1,Level2,Val1,To),-1) quit:To=""
					set Data=OrderedTree(Level1,Level2,Val1,To)
					set Operation=$piece(Data,",",1),Val2=$piece(Data,",",2)
					//1 - Simple assignment
					//2 - NOT (bitwise complement)
					//3 - OR
					//4 - AND
					//5 - RSHIFT
					//6 - LSHIFT
					set OperationName=$case(Operation,1:"Assignment",2:"NOT",3:"OR",4:"AND",5:"RSHIFT",6:"LSHIFT")
					write !,"Doing operation ",OperationName," to ",To," with values ",Val1
					if Operation>2 write " & ",Val2
					if Operation=1 set Values(To)=$select(Val1?1.n:$factor(Val1),1:Values(Val1))            //SET
					if Operation>1,Operation<5 {
						set bitVal1=$select(Val1?1.n:$factor(Val1),1:Values(Val1))
						if Operation>2 set bitVal2=$select(Val2?1.n:$factor(Val2),1:Values(Val2))
						if Operation=2 set Values(To)=$bitlogic(~bitVal1)                                      //NOT
						if Operation=3 set Values(To)=$bitlogic(bitVal1|bitVal2)                                  //OR
						if Operation=4 set Values(To)=$bitlogic(bitVal1&bitVal2)                                  //AND
					}
					if Operation>4 {
						if Operation=5 set startBit=1+Val2,dir=1,stopBit=16,offset=Val2*dir                 //RSHIFT
						if Operation=6 set startBit=16-Val2,stopBit=1,dir=-1,offset=Val2*dir                //LSHIFT
						for bit=startBit:dir:stopBit set $bit(Values(To),bit-offset)=$bit(Values(Val1),bit)
					}
				}
			}
		}
	}
	write !!
	set a=0 for bit=16:-1:1 set a=a*2+$bit(Values("a"),bit)
	
	/*
	zwrite Values
	zw OrderedTree
	w !!
	*/
	quit a
}
ComputeHeight(Node,Tree)
{
	if '$data(Tree(Node)) quit 0
	if $get(Tree(Node)) quit Tree(Node)
	set To="",MaxHeight=0 for  {
		set To=$order(Tree(Node,To)) quit:To=""
		set Height=1+$$ComputeHeight(To,.Tree)
		set:Height>MaxHeight MaxHeight=Height
	}
	set Tree(Node)=MaxHeight
	quit MaxHeight
}
	/*
Now, take the signal you got on wire a, override wire b to that signal, and reset the other wires (including wire a). What new signal is ultimately provided to wire a?
	*/
Part2(FileName="",RecordsArr) PUBLIC
{
	if $data(RecordsArr)'=10 {
		if '$length(FileName) {
			read !,"Enter filename: ",FileName
			write !
		}
		if '$length(FileName) {
			write !,"Missing file to read from"
			quit 0
		}
		quit:'$$LoadFile(FileName,.RecordsArr) 0
		if '$data(RecordsArr) {
			write !,"No data was red from "_FileName
			quit 0
		}
	}
	quit:'$$CheckData(.RecordsArr) 0
	set a=$$Part1(,.RecordsArr)
	set Line="" for  {
		set Line=$order(RecordsArr(Line)) quit:Line=""
		set Data=RecordsArr(Line)
		if $extract(Data,*-4,*)=" -> b" set RecordsArr(Line)=a_" -> b" quit
	}
	quit $$Part1(,.RecordsArr)
}
CheckData(RecordsArr)
{
	set ERR=""
	set Line="" for  {
		set Line=$order(RecordsArr(Line)) quit:Line=""
		if $data(RecordsArr(Line))'=1 {
			set ERR="Wrong data"
			write !,ERR
			quit
		}
		set Data=RecordsArr(Line)
		if '$length(Data) {
			set ERR="Missing data in line "_Line
			write !,ERR
			quit
		}
		set DefaultError="Wrong data in line "_Line_"("_Data_")"
		if $length(Data," -> ")'=2 set ERR=$$DisplayErr(DefaultError_"-1") quit
		set To=$piece(Data," -> ",2)
		if To'?1.l set ERR=$$DisplayErr(DefaultError_"-2") quit  //?????? -> somevar
		set Command=$piece(Data," -> ",1)
		if ($length(Command," ")>3)||($length(Command," ")<1) set ERR=$$DisplayErr(DefaultError_"-3") quit
		if $length(Command," ")=1,Command'?1.n,Command'?1.l set ERR=$$DisplayErr(DefaultError_"-4") quit  //somevar1 -> somevar2     or     123 -> somevar
		if $length(Command," ")=2,Command'?1"NOT "1.l set ERR=$$DisplayErr(DefaultError_"-5") quit  //NOT somevar1 -> somevar2
		if $length(Command," ")=3 {
			set Operation=$piece(Command," ",2)
			if ",OR,AND,RSHIFT,LSHIFT,"'[(","_Operation_",") set ERR=$$DisplayErr(DefaultError_"-6") quit  // ??? OR/AND/RSHIFT/LSHIFT ??? -> somevar
			set Val1=$piece(Command," ",1),Val2=$piece(Command," ",3)
			if ((Val1'?1.n)&&(Val1'?1.l))||((Val2'?1.n)&&(Val2'?1.l)) set ERR=$$DisplayErr(DefaultError_"-7") quit
			if ",RSHIFT,LSHIFT,"[(","_Operation_",") {
				if (Val1'?1.l)||(Val2'?1.2n) set ERR=$$DisplayErr(DefaultError_"-8") quit   // somevar RSHIFT/LSHIFT 12 -> somevar
				if (Val2<1)||(Val2>15) set ERR=$$DisplayErr(DefaultError_"-9") quit   // somevar RSHIFT/LSHIFT 12 -> somevar
			}
		}
		if $data(Wire(To)) set ERR=$$DisplayErr("Multi wire "_To_" definition in lines #"_Wire(To)_"&#"_Line_"-10") quit
		set Wire(To)=Line
	}
	quit:$length(ERR) 0
	quit 1
}
DisplayErr(Error)
{
	write !,Error
	quit Error
}
LoadFile(FileName,RecordsArr)
{
	kill RecordsArr
	open FileName::2 if '$test {
		write !,"Error loading file "_FileName
		quit 0
	}
	set EndOfFileSW=$system.Process.SetZEOF(1)
	use FileName
	for Line=1:1 {
		read Record quit:$zeof
		if $length(Record) set RecordsArr(Line)=Record
	}
	close FileName
	if 'EndOfFileSW do $system.Process.SetZEOF(0)
	quit 1
}

