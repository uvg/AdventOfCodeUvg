ROUTINE YUVGZ201921 [Type=INT]
YUVGZ201921	;https://adventofcode.com/2019/day/21;
	//Intersystems developer community id: 130669-ab1f69bf
	quit
	/*
109,2050,21102,966,1,1,21101,0,13,0,1106,0,1378,21101,0,20,0,1105,1,1337,21101,27,0,0,1105,1,1279,1208,1,65,748,1005,748,73,1208,1,79,748,1005,748,110,1208,1,78,748,1005,748,132,1208,1,87,748,1005,748,169,1208,1,82,748,1005,748,239,21102,1,1041,1,21102,1,73,0,1105,1,1421,21101,0,78,1,21101,0,1041,2,21102,1,88,0,1105,1,1301,21101,0,68,1,21102,1041,1,2,21102,103,1,0,1105,1,1301,1102,1,1,750,1105,1,298,21101,82,0,1,21102,1,1041,2,21102,1,125,0,1105,1,1301,1101,0,2,750,1106,0,298,21101,79,0,1,21102,1,1041,2,21102,1,147,0,1105,1,1301,21102,84,1,1,21101,0,1041,2,21102,162,1,0,1105,1,1301,1102,3,1,750,1106,0,298,21101,0,65,1,21102,1,1041,2,21101,184,0,0,1105,1,1301,21102,1,76,1,21102,1,1041,2,21102,199,1,0,1105,1,1301,21101,75,0,1,21102,1041,1,2,21102,1,214,0,1105,1,1301,21102,221,1,0,1105,1,1337,21102,1,10,1,21101,1041,0,2,21102,1,236,0,1106,0,1301,1106,0,553,21101,0,85,1,21101,0,1041,2,21102,1,254,0,1105,1,1301,21101,78,0,1,21102,1041,1,2,21102,1,269,0,1106,0,1301,21101,0,276,0,1106,0,1337,21102,1,10,1,21101,1041,0,2,21101,0,291,0,1105,1,1301,1102,1,1,755,1106,0,553,21101,32,0,1,21102,1,1041,2,21101,0,313,0,1106,0,1301,21102,320,1,0,1105,1,1337,21101,327,0,0,1106,0,1279,1201,1,0,749,21102,1,65,2,21102,73,1,3,21102,1,346,0,1105,1,1889,1206,1,367,1007,749,69,748,1005,748,360,1101,0,1,756,1001,749,-64,751,1105,1,406,1008,749,74,748,1006,748,381,1101,-1,0,751,1105,1,406,1008,749,84,748,1006,748,395,1101,-2,0,751,1106,0,406,21101,0,1100,1,21101,0,406,0,1106,0,1421,21102,32,1,1,21101,0,1100,2,21101,0,421,0,1105,1,1301,21102,428,1,0,1105,1,1337,21101,0,435,0,1106,0,1279,2101,0,1,749,1008,749,74,748,1006,748,453,1102,-1,1,752,1106,0,478,1008,749,84,748,1006,748,467,1102,-2,1,752,1105,1,478,21101,1168,0,1,21101,478,0,0,1105,1,1421,21101,0,485,0,1105,1,1337,21101,10,0,1,21102,1168,1,2,21101,0,500,0,1105,1,1301,1007,920,15,748,1005,748,518,21101,0,1209,1,21102,518,1,0,1106,0,1421,1002,920,3,529,1001,529,921,529,1002,750,1,0,1001,529,1,537,1002,751,1,0,1001,537,1,545,101,0,752,0,1001,920,1,920,1105,1,13,1005,755,577,1006,756,570,21102,1,1100,1,21102,1,570,0,1105,1,1421,21101,0,987,1,1105,1,581,21101,0,1001,1,21102,588,1,0,1105,1,1378,1101,758,0,594,102,1,0,753,1006,753,654,21001,753,0,1,21101,610,0,0,1106,0,667,21101,0,0,1,21102,1,621,0,1106,0,1463,1205,1,647,21102,1015,1,1,21102,1,635,0,1106,0,1378,21102,1,1,1,21102,646,1,0,1106,0,1463,99,1001,594,1,594,1106,0,592,1006,755,664,1101,0,0,755,1106,0,647,4,754,99,109,2,1102,1,726,757,22101,0,-1,1,21102,1,9,2,21102,697,1,3,21102,1,692,0,1106,0,1913,109,-2,2105,1,0,109,2,101,0,757,706,2101,0,-1,0,1001,757,1,757,109,-2,2106,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,255,63,95,127,159,223,191,0,69,237,34,117,213,198,217,216,221,172,218,185,178,53,177,174,122,163,196,226,103,162,70,111,46,84,233,238,246,206,245,175,166,157,42,248,47,212,118,109,56,121,108,200,92,78,190,155,215,235,59,38,182,76,234,49,71,116,137,68,43,220,107,169,125,179,204,99,54,152,189,123,173,143,232,124,86,126,252,139,241,214,183,187,39,244,113,136,188,203,253,171,58,184,57,242,98,140,154,205,168,119,85,102,239,50,222,100,55,60,229,228,247,79,197,254,35,51,153,167,227,142,251,94,201,249,61,110,62,236,114,158,141,170,219,77,156,138,101,250,199,106,181,243,230,115,202,231,93,120,186,87,207,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,73,110,112,117,116,32,105,110,115,116,114,117,99,116,105,111,110,115,58,10,13,10,87,97,108,107,105,110,103,46,46,46,10,10,13,10,82,117,110,110,105,110,103,46,46,46,10,10,25,10,68,105,100,110,39,116,32,109,97,107,101,32,105,116,32,97,99,114,111,115,115,58,10,10,58,73,110,118,97,108,105,100,32,111,112,101,114,97,116,105,111,110,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,78,68,44,32,79,82,44,32,111,114,32,78,79,84,67,73,110,118,97,108,105,100,32,102,105,114,115,116,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,44,32,66,44,32,67,44,32,68,44,32,74,44,32,111,114,32,84,40,73,110,118,97,108,105,100,32,115,101,99,111,110,100,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,74,32,111,114,32,84,52,79,117,116,32,111,102,32,109,101,109,111,114,121,59,32,97,116,32,109,111,115,116,32,49,53,32,105,110,115,116,114,117,99,116,105,111,110,115,32,99,97,110,32,98,101,32,115,116,111,114,101,100,0,109,1,1005,1262,1270,3,1262,21002,1262,1,0,109,-1,2106,0,0,109,1,21101,0,1288,0,1105,1,1263,21001,1262,0,0,1101,0,0,1262,109,-1,2106,0,0,109,5,21101,1310,0,0,1106,0,1279,21202,1,1,-2,22208,-2,-4,-1,1205,-1,1332,22101,0,-3,1,21101,1332,0,0,1105,1,1421,109,-5,2105,1,0,109,2,21101,0,1346,0,1105,1,1263,21208,1,32,-1,1205,-1,1363,21208,1,9,-1,1205,-1,1363,1106,0,1373,21101,0,1370,0,1105,1,1279,1105,1,1339,109,-2,2105,1,0,109,5,2102,1,-4,1386,20101,0,0,-2,22101,1,-4,-4,21101,0,0,-3,22208,-3,-2,-1,1205,-1,1416,2201,-4,-3,1408,4,0,21201,-3,1,-3,1106,0,1396,109,-5,2106,0,0,109,2,104,10,21201,-1,0,1,21101,0,1436,0,1106,0,1378,104,10,99,109,-2,2105,1,0,109,3,20002,594,753,-1,22202,-1,-2,-1,201,-1,754,754,109,-3,2105,1,0,109,10,21102,5,1,-5,21101,1,0,-4,21101,0,0,-3,1206,-9,1555,21102,1,3,-6,21101,0,5,-7,22208,-7,-5,-8,1206,-8,1507,22208,-6,-4,-8,1206,-8,1507,104,64,1105,1,1529,1205,-6,1527,1201,-7,716,1515,21002,0,-11,-8,21201,-8,46,-8,204,-8,1105,1,1529,104,46,21201,-7,1,-7,21207,-7,22,-8,1205,-8,1488,104,10,21201,-6,-1,-6,21207,-6,0,-8,1206,-8,1484,104,10,21207,-4,1,-8,1206,-8,1569,21101,0,0,-9,1106,0,1689,21208,-5,21,-8,1206,-8,1583,21101,0,1,-9,1105,1,1689,1201,-5,716,1589,20102,1,0,-2,21208,-4,1,-1,22202,-2,-1,-1,1205,-2,1613,21201,-5,0,1,21101,0,1613,0,1105,1,1444,1206,-1,1634,21201,-5,0,1,21101,1627,0,0,1105,1,1694,1206,1,1634,21101,0,2,-3,22107,1,-4,-8,22201,-1,-8,-8,1206,-8,1649,21201,-5,1,-5,1206,-3,1663,21201,-3,-1,-3,21201,-4,1,-4,1106,0,1667,21201,-4,-1,-4,21208,-4,0,-1,1201,-5,716,1676,22002,0,-1,-1,1206,-1,1686,21101,0,1,-4,1106,0,1477,109,-10,2105,1,0,109,11,21101,0,0,-6,21102,0,1,-8,21102,1,0,-7,20208,-6,920,-9,1205,-9,1880,21202,-6,3,-9,1201,-9,921,1724,21001,0,0,-5,1001,1724,1,1733,20102,1,0,-4,21201,-4,0,1,21101,1,0,2,21102,1,9,3,21101,1754,0,0,1105,1,1889,1206,1,1772,2201,-10,-4,1767,1001,1767,716,1767,20101,0,0,-3,1106,0,1790,21208,-4,-1,-9,1206,-9,1786,21202,-8,1,-3,1106,0,1790,21201,-7,0,-3,1001,1733,1,1795,21001,0,0,-2,21208,-2,-1,-9,1206,-9,1812,21201,-8,0,-1,1106,0,1816,22101,0,-7,-1,21208,-5,1,-9,1205,-9,1837,21208,-5,2,-9,1205,-9,1844,21208,-3,0,-1,1106,0,1855,22202,-3,-1,-1,1105,1,1855,22201,-3,-1,-1,22107,0,-1,-1,1105,1,1855,21208,-2,-1,-9,1206,-9,1869,21202,-1,1,-8,1106,0,1873,21202,-1,1,-7,21201,-6,1,-6,1105,1,1708,21202,-8,1,-10,109,-11,2106,0,0,109,7,22207,-6,-5,-3,22207,-4,-6,-2,22201,-3,-2,-1,21208,-1,0,-6,109,-7,2106,0,0,0,109,5,2101,0,-2,1912,21207,-4,0,-1,1206,-1,1930,21102,1,0,-4,22101,0,-4,1,22102,1,-3,2,21101,1,0,3,21102,1,1949,0,1106,0,1954,109,-5,2106,0,0,109,6,21207,-4,1,-1,1206,-1,1977,22207,-5,-3,-1,1206,-1,1977,22102,1,-5,-5,1106,0,2045,21201,-5,0,1,21201,-4,-1,2,21202,-3,2,3,21101,0,1996,0,1105,1,1954,21202,1,1,-5,21102,1,1,-2,22207,-5,-3,-1,1206,-1,2015,21102,0,1,-2,22202,-3,-2,-3,22107,0,-4,-1,1206,-1,2037,22101,0,-2,1,21102,2037,1,0,106,0,1912,21202,-3,-1,-3,22201,-5,-3,-5,109,-6,2105,1,0
	*/
	/*
You lift off from Pluto and start flying in the direction of Santa.

While experimenting further with the tractor beam, you accidentally pull an asteroid directly into your ship! It deals significant damage to your hull and causes your ship to begin tumbling violently.

You can send a droid out to investigate, but the tumbling is causing enough artificial gravity that one wrong step could send the droid through a hole in the hull and flying out into space.

The clear choice for this mission is a droid that can jump over the holes in the hull - a springdroid.

You can use an Intcode program (your puzzle input) running on an ASCII-capable computer to program the springdroid. However, springdroids don't run Intcode; instead, they run a simplified assembly language called springscript.

While a springdroid is certainly capable of navigating the artificial gravity and giant holes, it has one downside: it can only remember at most 15 springscript instructions.

The springdroid will move forward automatically, constantly thinking about whether to jump. The springscript program defines the logic for this decision.

Springscript programs only use Boolean values, not numbers or strings. Two registers are available: T, the temporary value register, and J, the jump register. If the jump register is true at the end of the springscript program, the springdroid will try to jump. Both of these registers start with the value false.

Springdroids have a sensor that can detect whether there is ground at various distances in the direction it is facing; these values are provided in read-only registers. Your springdroid can detect ground at four distances: one tile away (A), two tiles away (B), three tiles away (C), and four tiles away (D). If there is ground at the given distance, the register will be true; if there is a hole, the register will be false.

There are only three instructions available in springscript:

AND X Y sets Y to true if both X and Y are true; otherwise, it sets Y to false.
OR X Y sets Y to true if at least one of X or Y is true; otherwise, it sets Y to false.
NOT X Y sets Y to true if X is false; otherwise, it sets Y to false.
In all three instructions, the second argument (Y) needs to be a writable register (either T or J). The first argument (X) can be any register (including A, B, C, or D).

For example, the one-instruction program NOT A J means "if the tile immediately in front of me is not ground, jump".

Or, here is a program that jumps if a three-tile-wide hole (with ground on the other side of the hole) is detected:

NOT A J
NOT B T
AND T J
NOT C T
AND T J
AND D J
The Intcode program expects ASCII inputs and outputs. It will begin by displaying a prompt; then, input the desired instructions one per line. End each line with a newline (ASCII code 10). When you have finished entering your program, provide the command WALK followed by a newline to instruct the springdroid to begin surveying the hull.

If the springdroid falls into space, an ASCII rendering of the last moments of its life will be produced. In these, @ is the springdroid, # is hull, and . is empty space. For example, suppose you program the springdroid like this:

NOT D J
WALK
This one-instruction program sets J to true if and only if there is no ground four tiles away. In other words, it attempts to jump into any hole it finds:

.................
.................
@................
#####.###########

.................
.................
.@...............
#####.###########

.................
..@..............
.................
#####.###########

...@.............
.................
.................
#####.###########

.................
....@............
.................
#####.###########

.................
.................
.....@...........
#####.###########

.................
.................
.................
#####@###########
However, if the springdroid successfully makes it across, it will use an output instruction to indicate the amount of damage to the hull as a single giant integer outside the normal ASCII range.

Program the springdroid with logic that allows it to survey the hull without falling into space. What amount of hull damage does it report?
	*/
Part1(FileName="",Data="") PUBLIC
{
	if '$length(Data) {
		if '$length(FileName) {
			read !,"Enter filename: ",FileName
			write !
		}
		if '$length(FileName) {
			write !,"Missing file to read from"
			quit 0
		}
		quit:'$$LoadFile(FileName,.RecordsArr) 0
		if '$data(RecordsArr) {
			write !,"No data was red from "_FileName
			quit 0
		}
		if ($order(RecordsArr(""))'=1)||($order(RecordsArr(""),-1)'=1) {
			write !,"Wrong data was red from "_FileName
			quit 0
		}
		set Data=RecordsArr(1)
	}
	quit:'$$CheckData(Data)
	kill ^mtempSORT($zname,"Part1")
	set ^mtempSORT($zname,"PartKey")="Part1"
	do SetCommands("Part1")
	do ComputeSignalCode(Data,,.ERR,,0,,,"Output","Input")
	quit:$length(ERR) 0
	quit 1
}
SetCommands(PartKey)
{
	set ^mtempSORT($zname,PartKey,"Commands","Current")=1,^mtempSORT($zname,PartKey,"Commands","Index")=0
	if PartKey="Part1" {
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT A J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT C T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="AND D T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR T J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="WALK"
	}
	else {
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT F J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR E J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR H J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="AND D J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT C T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="AND T J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT D T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR B T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR E T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT T T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR T J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT A T"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR T J"
		set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="RUN"
	}
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT T J"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT A J"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT J J"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="OR T J"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT B T"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="NOT T T"
	//set ^mtempSORT($zname,PartKey,"Commands",$increment(Command))="AND T J"
	//set ^mtempSORT($zname,PartKey,"Commands",1)="NOT B T"
	//set ^mtempSORT($zname,PartKey,"Commands",2)="WALK"
	//set ^mtempSORT($zname,PartKey,"Commands",3)="OR T J"
	//set ^mtempSORT($zname,PartKey,"Commands",4)="AND B J"
	//set ^mtempSORT($zname,PartKey,"Commands",5)="AND C J"
	//set ^mtempSORT($zname,PartKey,"Commands",6)="WALK"
	//set ^mtempSORT($zname,PartKey,"Commands",6)="AND T J"
	//set ^mtempSORT($zname,PartKey,"Commands",7)="WALK"
	//set ^mtempSORT($zname,PartKey,"Commands",1)="NOT A T"
	//set ^mtempSORT($zname,PartKey,"Commands",2)="NOT B J"
	//set ^mtempSORT($zname,PartKey,"Commands",3)="AND T J"
	//set ^mtempSORT($zname,PartKey,"Commands",4)="NOT C T"
	//set ^mtempSORT($zname,PartKey,"Commands",5)="AND T J"
	//set ^mtempSORT($zname,PartKey,"Commands",6)="AND D J"
	//set ^mtempSORT($zname,PartKey,"Commands",6)="NOT D T"
	//set ^mtempSORT($zname,PartKey,"Commands",7)="AND T J"
	//set ^mtempSORT($zname,PartKey,"Commands",8)="WALK"
	zwrite ^mtempSORT($zname,PartKey,"Commands")
}
Input(Line)
	set PartKey=^mtempSORT($zname,"PartKey")
	set CurrentCommand=^mtempSORT($zname,PartKey,"Commands","Current"),IndexCommand=^mtempSORT($zname,PartKey,"Commands","Index")
	set IndexCommand=IndexCommand+1
	set Command=^mtempSORT($zname,PartKey,"Commands",CurrentCommand)
	//w Command,!,IndexCommand,!
	if IndexCommand>$length(Command) {
		//w Command,!
		set NextCommand=CurrentCommand+1
		set ^mtempSORT($zname,PartKey,"Commands","Current")=NextCommand
		set ^mtempSORT($zname,PartKey,"Commands","Index")=0
		quit 10
	}
	set Val=$ascii(Command,IndexCommand)
	set ^mtempSORT($zname,PartKey,"Commands","Index")=IndexCommand
	//w Val
	quit Val
Output(Line,Val)
	set PartKey=^mtempSORT($zname,"PartKey")
	set ^mtempSORT($zname,PartKey,"LastVal")=Val
	if Val>255 {
		write Val,!
		quit
	}
	//write $c(Val)
	if Val'=10 {
		write $char(Val)
	}
	if Val=10 {
		write !
	}
	quit
    ;              1     2     3        4                   5          6      7        8               9
ComputeSignalCode(Data,Inputs,ERR,InstructionPointer=1,ExitOpCode4=0,ExitSW,Output,OutputLabel="",InputLabel="")
{
	set OpCode="",ERR="",DiagnosticCode="",InputId=0,ExitSW=0,Offset=0,Line=0
	//w !,"Data before: ",Data
	while OpCode'=99&&'$length(ERR)&&'ExitSW {
		if Data[",," for i=1:1:$length(Data,",") if $piece(Data,",",i)="" set $piece(Data,",",i)=0
		set Instruction=$piece(Data,",",InstructionPointer)
		;W !,Instruction,"@",InstructionPointer
		if Instruction'?1.5n {
			set ERR="Wrong instruction "_Instruction
			quit 
		}
		set OpCode=+$extract(Instruction,*-1,*)
		if ",1,2,3,4,5,6,7,8,9,99,"'[(","_OpCode_",") {
			set ERR="Unknown operation "_OpCode
			quit
		}
		set ParametersMode=$extract(Instruction,1,*-2)
		//w !,"Instruction=",Instruction,";","Offset=",Offset
		if OpCode=99
		{
			if $length(ParametersMode) set ERR="Exit operation with parmaters "_ParametersMode
			set ExitSW=1
			//write !,"Finish computing, exiting code",!!
			quit
		}
		if OpCode=1
		{
			if $extract(ParametersMode,1,*-2)>2||($extract(ParametersMode,*-2)=1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val1=$piece(Data,",",InstructionPointer+1) ;W !,"<",Val1
			set Val2=$piece(Data,",",InstructionPointer+2) ;W !,"<",Val2
			set OutPos=$piece(Data,",",InstructionPointer+3) ;W !,"<",OutPos
			if '$extract(ParametersMode,*) set Val1=$piece(Data,",",Val1+1) ;W !,"@",Val1
			if '$extract(ParametersMode,*-1) set Val2=$piece(Data,",",Val2+1) ;W !,"@",Val2
			if $extract(ParametersMode,*)=2 set Val1=$piece(Data,",",Val1+Offset+1) ;W !,"@",Val1
			if $extract(ParametersMode,*-1)=2 set Val2=$piece(Data,",",Val2+Offset+1) ;W !,"@",Val2
			if $extract(ParametersMode,*-2)=2 set OutPos=OutPos+Offset ;$piece(Data,",",OutPos+Offset+1) ;W !,"@",OutPos
			set Val=Val1+Val2
			;w !,Val_">"_OutPos
			//w !,"Operation 1>>Add "_Val1_"+"_Val2_" and store it in "_OutPos
			//w !,"Data before "_Data
			set $piece(Data,",",OutPos+1)=Val
			//w !,"Data after "_Data
			set InstructionPointer=InstructionPointer+4
			continue
		}
		if OpCode=2
		{
			if $extract(ParametersMode,1,*-2)>2||($extract(ParametersMode,*-2)=1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val1=$piece(Data,",",InstructionPointer+1)
			set Val2=$piece(Data,",",InstructionPointer+2)
			set OutPos=$piece(Data,",",InstructionPointer+3)
			if '$extract(ParametersMode,*) set Val1=$piece(Data,",",Val1+1)
			if '$extract(ParametersMode,*-1) set Val2=$piece(Data,",",Val2+1)
			if $extract(ParametersMode,*)=2 set Val1=$piece(Data,",",Val1+Offset+1)
			if $extract(ParametersMode,*-1)=2 set Val2=$piece(Data,",",Val2+Offset+1)
			if $extract(ParametersMode,*-2)=2 set OutPos=OutPos+Offset ;$piece(Data,",",OutPos+Offset+1)
			set $piece(Data,",",OutPos+1)=Val1*Val2
			set InstructionPointer=InstructionPointer+4
			continue
		}
		if OpCode=3
		{
			if $extract(ParametersMode,1,*-1)||(ParametersMode=1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set OutPos=$piece(Data,",",InstructionPointer+1)
			if $extract(ParametersMode,*)=2 set OutPos=OutPos+Offset ;$piece(Data,",",OutPos+Offset+1)
			set InputId=InputId+1
			if $data(Inputs(InputId)) {
				set Val=Inputs(InputId)
			}
			elseif $length(InputLabel) {
				set Val=$$Input(Line)
			}
			else {
				read !,"Please enter value: ",Val
				write !
			}
			set $piece(Data,",",OutPos+1)=Val
			set InstructionPointer=InstructionPointer+2
			continue
		}
		if OpCode=4
		{
			if $extract(ParametersMode,1,*-1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val=$piece(Data,",",InstructionPointer+1)
			if '$extract(ParametersMode,*) set Val=$piece(Data,",",Val+1)
			if $extract(ParametersMode,*)=2 set Val=$piece(Data,",",Val+Offset+1)
			set:'$length(Val) Val=0
			set Line=Line+1
			if '$data(Output) {
				if $length(OutputLabel) do @(OutputLabel_"("_Line_","_$select((Val?1.N)&&($extract(Val)||(Val=0)):Val,1:""""_Val_"""")_")")
				write:'$length(OutputLabel) !,Val
			}
			else {
				set Output(Line)=Val
			}
			set DiagnosticCode=Val
			set InstructionPointer=InstructionPointer+2
			quit:ExitOpCode4
			continue
		}
		if OpCode=5
		{
			if $extract(ParametersMode,1,*-2) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val=$piece(Data,",",InstructionPointer+1)
			if '$extract(ParametersMode,*) set Val=$piece(Data,",",Val+1)
			if $extract(ParametersMode,*)=2 set Val=$piece(Data,",",Val+Offset+1)
			if Val {
				set InstructionPointer=$piece(Data,",",InstructionPointer+2)
				if '$extract(ParametersMode,*-1) set InstructionPointer=$piece(Data,",",InstructionPointer+1)
				if $extract(ParametersMode,*-1)=2 set InstructionPointer=$piece(Data,",",InstructionPointer+Offset+1)
				set InstructionPointer=InstructionPointer+1
				continue
			}
			set InstructionPointer=InstructionPointer+3
			continue
		}
		if OpCode=6
		{
			if $extract(ParametersMode,1,*-2) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val=$piece(Data,",",InstructionPointer+1)
			if '$extract(ParametersMode,*) set Val=$piece(Data,",",Val+1)
			if $extract(ParametersMode,*)=2 set Val=$piece(Data,",",Val+Offset+1)
			if 'Val {
				set InstructionPointer=$piece(Data,",",InstructionPointer+2)
				if '$extract(ParametersMode,*-1) set InstructionPointer=$piece(Data,",",InstructionPointer+1)
				if $extract(ParametersMode,*-1)=2 set InstructionPointer=$piece(Data,",",InstructionPointer+Offset+1)
				set InstructionPointer=InstructionPointer+1
				continue
			}
			set InstructionPointer=InstructionPointer+3
			continue
		}
		if OpCode=7
		{
			if $extract(ParametersMode,1,*-2)>2||($extract(ParametersMode,*-2)=1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val1=$piece(Data,",",InstructionPointer+1)
			set Val2=$piece(Data,",",InstructionPointer+2)
			set OutPos=$piece(Data,",",InstructionPointer+3)
			if '$extract(ParametersMode,*) set Val1=$piece(Data,",",Val1+1)
			if '$extract(ParametersMode,*-1) set Val2=$piece(Data,",",Val2+1)
			if $extract(ParametersMode,*)=2 set Val1=$piece(Data,",",Val1+Offset+1)
			if $extract(ParametersMode,*-1)=2 set Val2=$piece(Data,",",Val2+Offset+1)
			if $extract(ParametersMode,*-2)=2 set OutPos=OutPos+Offset ;$piece(Data,",",OutPos+Offset+1)
			set Val=Val1<Val2
			set $piece(Data,",",OutPos+1)=Val
			set InstructionPointer=InstructionPointer+4
			continue
		}
		if OpCode=8
		{
			if $extract(ParametersMode,1,*-2)>2||($extract(ParametersMode,*-2)=1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val1=$piece(Data,",",InstructionPointer+1)
			set Val2=$piece(Data,",",InstructionPointer+2)
			set OutPos=$piece(Data,",",InstructionPointer+3)
			if '$extract(ParametersMode,*) set Val1=$piece(Data,",",Val1+1)
			if '$extract(ParametersMode,*-1) set Val2=$piece(Data,",",Val2+1)
			if $extract(ParametersMode,*)=2 set Val1=$piece(Data,",",Val1+Offset+1)
			if $extract(ParametersMode,*-1)=2 set Val2=$piece(Data,",",Val2+Offset+1)
			if $extract(ParametersMode,*-2)=2 set OutPos=OutPos+Offset ;$piece(Data,",",OutPos+Offset+1)
			set:'$length(Val1) Val1=0
			set:'$length(Val2) Val2=0
			set Val=Val1=Val2
			set $piece(Data,",",OutPos+1)=Val
			set InstructionPointer=InstructionPointer+4
			continue
		}
		if OpCode=9
		{
			if $extract(ParametersMode,1,*-1) {
				set ERR="Wrong parameter mode for output the instruction "_Instruction
				quit
			}
			set Val=$piece(Data,",",InstructionPointer+1)
			if '$extract(ParametersMode,*) set Val=$piece(Data,",",Val+1)
			if $extract(ParametersMode,*)=2 set Val=$piece(Data,",",Val+Offset+1)
			set Offset=Offset+Val
			set InstructionPointer=InstructionPointer+2
			continue
		}

		set ERR="Unknown operation for instruction "_Instruction
		quit
	}
	if $length(ERR) {
		write !,ERR
		quit 0
	}
	//w !,"Data after: ",Data
	//write !,"Diagnostic Code is: "_DiagnosticCode
	quit DiagnosticCode
}

	/*
There are many areas the springdroid can't reach. You flip through the manual and discover a way to increase its sensor range.

Instead of ending your springcode program with WALK, use RUN. Doing this will enable extended sensor mode, capable of sensing ground up to nine tiles away. This data is available in five new read-only registers:

Register E indicates whether there is ground five tiles away.
Register F indicates whether there is ground six tiles away.
Register G indicates whether there is ground seven tiles away.
Register H indicates whether there is ground eight tiles away.
Register I indicates whether there is ground nine tiles away.
All other functions remain the same.

Successfully survey the rest of the hull by ending your program with RUN. What amount of hull damage does the springdroid now report?
	*/
Part2(FileName="",Data="") PUBLIC
{
	if '$length(Data) {
		if '$length(FileName) {
			read !,"Enter filename: ",FileName
			write !
		}
		if '$length(FileName) {
			write !,"Missing file to read from"
			quit 0
		}
		quit:'$$LoadFile(FileName,.RecordsArr) 0
		if '$data(RecordsArr) {
			write !,"No data was red from "_FileName
			quit 0
		}
		if ($order(RecordsArr(""))'=1)||($order(RecordsArr(""),-1)'=1) {
			write !,"Wrong data was red from "_FileName
			quit 0
		}
		set Data=RecordsArr(1)
	}
	quit:'$$CheckData(Data)
	kill ^mtempSORT($zname,"Part2")
	set ^mtempSORT($zname,"PartKey")="Part2"
	do SetCommands("Part2")
	do ComputeSignalCode(Data,,.ERR,,0,,,"Output","Input")
	quit:$length(ERR) 0
	quit 1
}
CheckData(Data)
{
	if $length(Data,",")<2,Data'=99 {
		write !,"Wrong data "_Data
		quit 0
	}
	set ERR=""
	for Location=1:1:$length(Data,",") {
		set Val=$piece(Data,",",Location)
		if Val'?.1"-"1.n {
			set ERR="Wrong value "_val
			write !,ERR
			quit
		}
	}
	quit:$length(ERR) 0
	quit 1
}
LoadFile(FileName,RecordsArr)
{
	kill RecordsArr
	open FileName::2 if '$test {
		write !,"Error loading file "_FileName
		quit 0
	}
	set EndOfFileSW=$zutil(68,40,1) //$system.Process.SetZEOF(1)
	use FileName
	for Line=1:1 {
		read Record quit:$zeof
		if $length(Record) set RecordsArr(Line)=Record
	}
	close FileName
	if 'EndOfFileSW do $zutil(68,40,0) //$system.Process.SetZEOF(0)
	quit 1
}
